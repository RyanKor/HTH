{"remainingRequest":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-scrollactive\\src\\scrollactive.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-scrollactive\\src\\scrollactive.vue","mtime":499162500000},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1563805362193},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":1563805359688},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1563805362193},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-loader\\lib\\index.js","mtime":1563805391247}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n\nimport bezierEasing from 'bezier-easing';\n\nexport default {\n  props: {\n    /**\n     * Class that will be applied in the menu item.\n     *\n     * @default 'is-active'\n     * @type {String}\n     */\n    activeClass: {\n      type: String,\n      default: 'is-active',\n    },\n\n    /**\n     * Amount of space between top of screen and the section to highlight. (Usually your fixed\n     * header's height)\n     *\n     * @default 20\n     * @type {Number}\n     */\n    offset: {\n      type: Number,\n      default: 20,\n    },\n\n    /**\n     * Amount of space between the top of the screen and the section to highlight when clicking a\n     * scrollactive item to scroll. It will use the value of the `offset` prop if none is provided\n     * here. Usefull when you want to use the `offset` prop to make an item be active as soon as\n     * it shows on the screen but still scroll to the top of the section when clicking the item.\n     */\n    scrollOffset: {\n      type: Number,\n      default: null,\n    },\n\n    /**\n     * The selector string of the scroll container element you'd like to use. It defaults to the\n     * window object (most common), but you might want to change in case you're using an element\n     * as the overflow container.\n     *\n     * @type {String}\n     */\n    scrollContainerSelector: {\n      type: String,\n      default: '',\n    },\n\n    /**\n     * Enables/disables the scrolling when clicking in a menu item.\n     * Disable if you'd like to handle the scrolling by your own.\n     *\n     * @default true\n     * @type {Boolean}\n     */\n    clickToScroll: {\n      type: Boolean,\n      default: true,\n    },\n\n    /**\n     * The duration of the scroll animation when clicking to scroll is activated.\n     *\n     * @default 600\n     * @type {Number}\n     */\n    duration: {\n      type: Number,\n      default: 600,\n    },\n\n    /**\n     * Defines if the plugin should track the section change when clicking an item to scroll to\n     * its section. If set to true, it will always keep track and change the active class to the\n     * current section while scrolling, if false, the active class will be immediately applied to\n     * the clicked menu item, ignoring the passed sections until the scrolling is over.\n     *\n     * @default false\n     * @type {Boolean}\n     */\n    alwaysTrack: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Your custom easing value for the click to scroll functionality.\n     * It must be a string with 4 values separated by commas in a cubic bezier format.\n     *\n     * @default '.5,0,.35,1'\n     * @type {String}\n     */\n    bezierEasingValue: {\n      type: String,\n      default: '.5,0,.35,1',\n    },\n\n    /**\n     * Decides if the URL should be modified with the section id when clicking a scrollactive\n     * item.\n     *\n     * @default true\n     * @type {Boolean}\n     */\n    modifyUrl: {\n      type: Boolean,\n      default: true,\n    },\n\n    /**\n     * If true the active class will only be applied when a section matches exactly one of the\n     * scrollactive items, meaning it will be highlighted when scrolling exactly inside the\n     * section. If false (default) it will always highlight the last item which was matched\n     * in a section, even if it is already outside that section (and not inside another that's\n     * being tracked).\n     *\n     * @default false\n     * @type {Boolean}\n     */\n    exact: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * If true the active class will be applied to the first scrollactive-item before you scroll\n     * past it (even if you didn't reach it yet).\n     */\n    highlightFirstItem: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Change the scroll active component html tag.\n     *\n     * @default nav\n     * @type {String}\n     */\n    tag: {\n      type: String,\n      default: 'nav',\n    },\n  },\n\n  data() {\n    return {\n      observer: null,\n      items: [],\n      currentItem: null,\n      lastActiveItem: null,\n      scrollAnimationFrame: null,\n      bezierEasing,\n    };\n  },\n\n  computed: {\n    /**\n     * Computes the bezier easing string value into an array.\n     *\n     * @return {Array.<string>}\n     */\n    cubicBezierArray() {\n      return this.bezierEasingValue.split(',');\n    },\n\n    scrollContainer() {\n      let container = window;\n\n      if (this.scrollContainerSelector) {\n        container = document.querySelector(this.scrollContainerSelector) || window;\n      }\n\n      return container;\n    },\n  },\n\n  mounted() {\n    const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n    if (!this.observer) {\n      // Watch for DOM changes in the scrollactive element wrapper\n      this.observer = new MutationObserver(this.initScrollactiveItems);\n      this.observer.observe(this.$refs['scrollactive-nav-wrapper'], {\n        childList: true,\n        subtree: true,\n      });\n    }\n\n    this.initScrollactiveItems();\n    this.removeActiveClass();\n    this.currentItem = this.getItemInsideWindow();\n\n    if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n\n    this.scrollToHashElement();\n    this.scrollContainer.addEventListener('scroll', this.onScroll);\n  },\n\n  updated() {\n    this.initScrollactiveItems();\n  },\n\n  beforeDestroy() {\n    this.scrollContainer.removeEventListener('scroll', this.onScroll);\n    window.cancelAnimationFrame(this.scrollAnimationFrame);\n  },\n\n  methods: {\n    /**\n     * Will be called when scrolling event is triggered to handle the addition of the active class\n     * in the current section item and fire the change event.\n     *\n     * @param {Object} event Scroll event.\n     */\n    onScroll(event) {\n      this.currentItem = this.getItemInsideWindow();\n\n      if (this.currentItem !== this.lastActiveItem) {\n        this.removeActiveClass();\n        this.$emit('itemchanged', event, this.currentItem, this.lastActiveItem);\n        this.lastActiveItem = this.currentItem;\n      }\n\n      // Current item might be null if not inside any section\n      if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n    },\n\n    /**\n     * Gets the scrollactive item that corresponds to the current section inside the window\n     *\n     * @return {Element} Scrollactive item element.\n     */\n    getItemInsideWindow() {\n      let currentItem;\n\n      // Must be called with 'call' to prevent bugs on some devices\n      [].forEach.call(this.items, (item) => {\n        const isFirstItem = (item === this.items[0]);\n        const target = document.getElementById(decodeURI(item.hash.substr(1)));\n\n        if (!target) return;\n\n        const distanceFromTop = this.scrollContainer.scrollTop || window.pageYOffset;\n        const isScreenPastSection = distanceFromTop >= this.getOffsetTop(target) - this.offset;\n        const isScreenBeforeSectionEnd = distanceFromTop\n          < (this.getOffsetTop(target) - this.offset) + target.offsetHeight;\n\n        if (isFirstItem && this.highlightFirstItem) {\n          if (isScreenBeforeSectionEnd) currentItem = item;\n        }\n\n        if (this.exact && isScreenPastSection && isScreenBeforeSectionEnd) currentItem = item;\n        if (!this.exact && isScreenPastSection) currentItem = item;\n      });\n\n      return currentItem;\n    },\n\n\n    /**\n     * Sets the list of menu items, adding or removing the click listener depending on the\n     * clickToScroll prop.\n     */\n    initScrollactiveItems() {\n      this.items = this.$el.querySelectorAll('.scrollactive-item');\n\n      if (this.clickToScroll) {\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          item.addEventListener('click', this.handleClick);\n        });\n\n        return;\n      }\n\n      // Must be called with 'call' to prevent bugs on some devices\n      [].forEach.call(this.items, (item) => {\n        item.removeEventListener('click', this.handleClick);\n      });\n    },\n\n    /**\n     * Keep the old setScrollactiveItems method in order to avoid breaking existing projects that\n     * used the previous version and upgraded to this one.\n     *\n     * @deprecated\n     */\n    setScrollactiveItems() {\n      this.initScrollactiveItems();\n    },\n\n    /**\n     * Handles the scrolling when clicking a menu item.\n     *\n     * @param {Object} event The click event.\n     */\n    handleClick(event) {\n      event.preventDefault();\n\n      const { hash } = event.currentTarget;\n      const target = document.getElementById(decodeURI(hash.substr(1)));\n\n      if (!target) {\n        console.warn(`[vue-scrollactive] Element '${hash}' was not found. Make sure it is set in the DOM.`);\n\n        return;\n      }\n\n      /**\n       *  Temporarily removes the scroll listener and the request animation frame so the active\n       *  class will only be applied to the clicked element, and not all elements while the window\n       *  is scrolling.\n       */\n      if (!this.alwaysTrack) {\n        this.scrollContainer.removeEventListener('scroll', this.onScroll);\n        window.cancelAnimationFrame(this.scrollAnimationFrame);\n\n        this.removeActiveClass();\n        event.currentTarget.classList.add(this.activeClass);\n      }\n\n      this.scrollTo(target)\n        .then(() => {\n          if (!this.alwaysTrack) {\n            this.scrollContainer.addEventListener('scroll', this.onScroll);\n            const findClickedItem = item => decodeURI(item.hash.substr(1)) === target.id;\n            this.currentItem = [].find.call(this.items, findClickedItem);\n\n            if (this.currentItem !== this.lastActiveItem) {\n              this.$emit('itemchanged', null, this.currentItem, this.lastActiveItem);\n              this.lastActiveItem = this.currentItem;\n            }\n          }\n\n          if (this.modifyUrl) {\n            this.pushHashToUrl(hash);\n          }\n        });\n    },\n\n    /**\n     * Scrolls the page to the given target element.\n     *\n     * @param {Element} target DOM Element to scroll to.\n     * @return {Promise} Returns a promise that will resolve when the animation is done.\n     */\n    scrollTo(target) {\n      return new Promise((resolve) => {\n        const targetDistanceFromTop = this.getOffsetTop(target);\n        const startingY = this.scrollContainer.scrollTop || window.pageYOffset;\n        const difference = targetDistanceFromTop - startingY;\n        const easing = this.bezierEasing(...this.cubicBezierArray);\n        let start = null;\n\n        const step = (timestamp) => {\n          if (!start) start = timestamp;\n\n          let progress = timestamp - start;\n          let progressPercentage = progress / this.duration;\n\n          if (progress >= this.duration) progress = this.duration;\n          if (progressPercentage >= 1) progressPercentage = 1;\n\n          const offset = this.scrollOffset || this.offset;\n          const perTick = startingY + (easing(progressPercentage) * (difference - offset));\n\n          this.scrollContainer.scrollTo(0, perTick);\n\n          if (progress < this.duration) {\n            this.scrollAnimationFrame = window.requestAnimationFrame(step);\n          } else {\n            resolve();\n          }\n        };\n\n        window.requestAnimationFrame(step);\n      });\n    },\n\n    /**\n     * Gets the top offset position of an element in the document.\n     *\n     * @param {Element} element\n     * @return {Number}\n     */\n    getOffsetTop(element) {\n      let yPosition = 0;\n      let nextElement = element;\n\n      while (nextElement) {\n        yPosition += (nextElement.offsetTop);\n        nextElement = nextElement.offsetParent;\n      }\n\n      if (this.scrollContainer.offsetTop) {\n        yPosition -= this.scrollContainer.offsetTop;\n      }\n\n      return yPosition;\n    },\n\n    /**\n     * Removes the active class from all scrollactive items.\n     */\n    removeActiveClass() {\n      // Must be called with 'call' to prevent bugs on some devices\n      [].forEach.call(this.items, (item) => {\n        item.classList.remove(this.activeClass);\n      });\n    },\n\n    /**\n     * Scrolls the page to the element passed as a hash in URL, preventing weird native scroll\n     * jumps while maintaining the hash in the URL.\n     */\n    scrollToHashElement() {\n      const { hash } = window.location;\n      if (!hash) return;\n\n      const hashElement = document.querySelector(decodeURI(hash));\n      if (!hashElement) return;\n\n      window.location.hash = ''; // Clears the hash to prevent scroll from jumping\n\n      setTimeout(() => {\n        const yPos = hashElement.offsetTop - this.offset;\n\n        this.scrollContainer.scrollTo(0, yPos);\n        // Sets the hash back with pushState so it won't jump to the element ignoring the offset\n        this.pushHashToUrl(hash);\n      }, 0);\n    },\n\n    /**\n     * Pushes the given hash to the URL using primarily pushState if available to prevent the\n     * scroll from jumping to the hash element. Uses window.location.hash as a fallback.\n     *\n     * @param {String} hash The hash value to be pushed\n     */\n    pushHashToUrl(hash) {\n      if (window.history.pushState) {\n        window.history.pushState(null, null, hash);\n\n        return;\n      }\n\n      window.location.hash = hash;\n    },\n  },\n};\n",{"version":3,"sources":["scrollactive.vue"],"names":[],"mappings":";;;;;;;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA","file":"scrollactive.vue","sourceRoot":"node_modules/vue-scrollactive/src","sourcesContent":["<template>\n  <component :is=\"tag\" class=\"scrollactive-nav\" ref=\"scrollactive-nav-wrapper\">\n    <slot></slot>\n  </component>\n</template>\n\n<script>\n  import bezierEasing from 'bezier-easing';\n\n  export default {\n    props: {\n      /**\n       * Class that will be applied in the menu item.\n       *\n       * @default 'is-active'\n       * @type {String}\n       */\n      activeClass: {\n        type: String,\n        default: 'is-active',\n      },\n\n      /**\n       * Amount of space between top of screen and the section to highlight. (Usually your fixed\n       * header's height)\n       *\n       * @default 20\n       * @type {Number}\n       */\n      offset: {\n        type: Number,\n        default: 20,\n      },\n\n      /**\n       * Amount of space between the top of the screen and the section to highlight when clicking a\n       * scrollactive item to scroll. It will use the value of the `offset` prop if none is provided\n       * here. Usefull when you want to use the `offset` prop to make an item be active as soon as\n       * it shows on the screen but still scroll to the top of the section when clicking the item.\n       */\n      scrollOffset: {\n        type: Number,\n        default: null,\n      },\n\n      /**\n       * The selector string of the scroll container element you'd like to use. It defaults to the\n       * window object (most common), but you might want to change in case you're using an element\n       * as the overflow container.\n       *\n       * @type {String}\n       */\n      scrollContainerSelector: {\n        type: String,\n        default: '',\n      },\n\n      /**\n       * Enables/disables the scrolling when clicking in a menu item.\n       * Disable if you'd like to handle the scrolling by your own.\n       *\n       * @default true\n       * @type {Boolean}\n       */\n      clickToScroll: {\n        type: Boolean,\n        default: true,\n      },\n\n      /**\n       * The duration of the scroll animation when clicking to scroll is activated.\n       *\n       * @default 600\n       * @type {Number}\n       */\n      duration: {\n        type: Number,\n        default: 600,\n      },\n\n      /**\n       * Defines if the plugin should track the section change when clicking an item to scroll to\n       * its section. If set to true, it will always keep track and change the active class to the\n       * current section while scrolling, if false, the active class will be immediately applied to\n       * the clicked menu item, ignoring the passed sections until the scrolling is over.\n       *\n       * @default false\n       * @type {Boolean}\n       */\n      alwaysTrack: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * Your custom easing value for the click to scroll functionality.\n       * It must be a string with 4 values separated by commas in a cubic bezier format.\n       *\n       * @default '.5,0,.35,1'\n       * @type {String}\n       */\n      bezierEasingValue: {\n        type: String,\n        default: '.5,0,.35,1',\n      },\n\n      /**\n       * Decides if the URL should be modified with the section id when clicking a scrollactive\n       * item.\n       *\n       * @default true\n       * @type {Boolean}\n       */\n      modifyUrl: {\n        type: Boolean,\n        default: true,\n      },\n\n      /**\n       * If true the active class will only be applied when a section matches exactly one of the\n       * scrollactive items, meaning it will be highlighted when scrolling exactly inside the\n       * section. If false (default) it will always highlight the last item which was matched\n       * in a section, even if it is already outside that section (and not inside another that's\n       * being tracked).\n       *\n       * @default false\n       * @type {Boolean}\n       */\n      exact: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * If true the active class will be applied to the first scrollactive-item before you scroll\n       * past it (even if you didn't reach it yet).\n       */\n      highlightFirstItem: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * Change the scroll active component html tag.\n       *\n       * @default nav\n       * @type {String}\n       */\n      tag: {\n        type: String,\n        default: 'nav',\n      },\n    },\n\n    data() {\n      return {\n        observer: null,\n        items: [],\n        currentItem: null,\n        lastActiveItem: null,\n        scrollAnimationFrame: null,\n        bezierEasing,\n      };\n    },\n\n    computed: {\n      /**\n       * Computes the bezier easing string value into an array.\n       *\n       * @return {Array.<string>}\n       */\n      cubicBezierArray() {\n        return this.bezierEasingValue.split(',');\n      },\n\n      scrollContainer() {\n        let container = window;\n\n        if (this.scrollContainerSelector) {\n          container = document.querySelector(this.scrollContainerSelector) || window;\n        }\n\n        return container;\n      },\n    },\n\n    mounted() {\n      const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n      if (!this.observer) {\n        // Watch for DOM changes in the scrollactive element wrapper\n        this.observer = new MutationObserver(this.initScrollactiveItems);\n        this.observer.observe(this.$refs['scrollactive-nav-wrapper'], {\n          childList: true,\n          subtree: true,\n        });\n      }\n\n      this.initScrollactiveItems();\n      this.removeActiveClass();\n      this.currentItem = this.getItemInsideWindow();\n\n      if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n\n      this.scrollToHashElement();\n      this.scrollContainer.addEventListener('scroll', this.onScroll);\n    },\n\n    updated() {\n      this.initScrollactiveItems();\n    },\n\n    beforeDestroy() {\n      this.scrollContainer.removeEventListener('scroll', this.onScroll);\n      window.cancelAnimationFrame(this.scrollAnimationFrame);\n    },\n\n    methods: {\n      /**\n       * Will be called when scrolling event is triggered to handle the addition of the active class\n       * in the current section item and fire the change event.\n       *\n       * @param {Object} event Scroll event.\n       */\n      onScroll(event) {\n        this.currentItem = this.getItemInsideWindow();\n\n        if (this.currentItem !== this.lastActiveItem) {\n          this.removeActiveClass();\n          this.$emit('itemchanged', event, this.currentItem, this.lastActiveItem);\n          this.lastActiveItem = this.currentItem;\n        }\n\n        // Current item might be null if not inside any section\n        if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n      },\n\n      /**\n       * Gets the scrollactive item that corresponds to the current section inside the window\n       *\n       * @return {Element} Scrollactive item element.\n       */\n      getItemInsideWindow() {\n        let currentItem;\n\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          const isFirstItem = (item === this.items[0]);\n          const target = document.getElementById(decodeURI(item.hash.substr(1)));\n\n          if (!target) return;\n\n          const distanceFromTop = this.scrollContainer.scrollTop || window.pageYOffset;\n          const isScreenPastSection = distanceFromTop >= this.getOffsetTop(target) - this.offset;\n          const isScreenBeforeSectionEnd = distanceFromTop\n            < (this.getOffsetTop(target) - this.offset) + target.offsetHeight;\n\n          if (isFirstItem && this.highlightFirstItem) {\n            if (isScreenBeforeSectionEnd) currentItem = item;\n          }\n\n          if (this.exact && isScreenPastSection && isScreenBeforeSectionEnd) currentItem = item;\n          if (!this.exact && isScreenPastSection) currentItem = item;\n        });\n\n        return currentItem;\n      },\n\n\n      /**\n       * Sets the list of menu items, adding or removing the click listener depending on the\n       * clickToScroll prop.\n       */\n      initScrollactiveItems() {\n        this.items = this.$el.querySelectorAll('.scrollactive-item');\n\n        if (this.clickToScroll) {\n          // Must be called with 'call' to prevent bugs on some devices\n          [].forEach.call(this.items, (item) => {\n            item.addEventListener('click', this.handleClick);\n          });\n\n          return;\n        }\n\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          item.removeEventListener('click', this.handleClick);\n        });\n      },\n\n      /**\n       * Keep the old setScrollactiveItems method in order to avoid breaking existing projects that\n       * used the previous version and upgraded to this one.\n       *\n       * @deprecated\n       */\n      setScrollactiveItems() {\n        this.initScrollactiveItems();\n      },\n\n      /**\n       * Handles the scrolling when clicking a menu item.\n       *\n       * @param {Object} event The click event.\n       */\n      handleClick(event) {\n        event.preventDefault();\n\n        const { hash } = event.currentTarget;\n        const target = document.getElementById(decodeURI(hash.substr(1)));\n\n        if (!target) {\n          console.warn(`[vue-scrollactive] Element '${hash}' was not found. Make sure it is set in the DOM.`);\n\n          return;\n        }\n\n        /**\n         *  Temporarily removes the scroll listener and the request animation frame so the active\n         *  class will only be applied to the clicked element, and not all elements while the window\n         *  is scrolling.\n         */\n        if (!this.alwaysTrack) {\n          this.scrollContainer.removeEventListener('scroll', this.onScroll);\n          window.cancelAnimationFrame(this.scrollAnimationFrame);\n\n          this.removeActiveClass();\n          event.currentTarget.classList.add(this.activeClass);\n        }\n\n        this.scrollTo(target)\n          .then(() => {\n            if (!this.alwaysTrack) {\n              this.scrollContainer.addEventListener('scroll', this.onScroll);\n              const findClickedItem = item => decodeURI(item.hash.substr(1)) === target.id;\n              this.currentItem = [].find.call(this.items, findClickedItem);\n\n              if (this.currentItem !== this.lastActiveItem) {\n                this.$emit('itemchanged', null, this.currentItem, this.lastActiveItem);\n                this.lastActiveItem = this.currentItem;\n              }\n            }\n\n            if (this.modifyUrl) {\n              this.pushHashToUrl(hash);\n            }\n          });\n      },\n\n      /**\n       * Scrolls the page to the given target element.\n       *\n       * @param {Element} target DOM Element to scroll to.\n       * @return {Promise} Returns a promise that will resolve when the animation is done.\n       */\n      scrollTo(target) {\n        return new Promise((resolve) => {\n          const targetDistanceFromTop = this.getOffsetTop(target);\n          const startingY = this.scrollContainer.scrollTop || window.pageYOffset;\n          const difference = targetDistanceFromTop - startingY;\n          const easing = this.bezierEasing(...this.cubicBezierArray);\n          let start = null;\n\n          const step = (timestamp) => {\n            if (!start) start = timestamp;\n\n            let progress = timestamp - start;\n            let progressPercentage = progress / this.duration;\n\n            if (progress >= this.duration) progress = this.duration;\n            if (progressPercentage >= 1) progressPercentage = 1;\n\n            const offset = this.scrollOffset || this.offset;\n            const perTick = startingY + (easing(progressPercentage) * (difference - offset));\n\n            this.scrollContainer.scrollTo(0, perTick);\n\n            if (progress < this.duration) {\n              this.scrollAnimationFrame = window.requestAnimationFrame(step);\n            } else {\n              resolve();\n            }\n          };\n\n          window.requestAnimationFrame(step);\n        });\n      },\n\n      /**\n       * Gets the top offset position of an element in the document.\n       *\n       * @param {Element} element\n       * @return {Number}\n       */\n      getOffsetTop(element) {\n        let yPosition = 0;\n        let nextElement = element;\n\n        while (nextElement) {\n          yPosition += (nextElement.offsetTop);\n          nextElement = nextElement.offsetParent;\n        }\n\n        if (this.scrollContainer.offsetTop) {\n          yPosition -= this.scrollContainer.offsetTop;\n        }\n\n        return yPosition;\n      },\n\n      /**\n       * Removes the active class from all scrollactive items.\n       */\n      removeActiveClass() {\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          item.classList.remove(this.activeClass);\n        });\n      },\n\n      /**\n       * Scrolls the page to the element passed as a hash in URL, preventing weird native scroll\n       * jumps while maintaining the hash in the URL.\n       */\n      scrollToHashElement() {\n        const { hash } = window.location;\n        if (!hash) return;\n\n        const hashElement = document.querySelector(decodeURI(hash));\n        if (!hashElement) return;\n\n        window.location.hash = ''; // Clears the hash to prevent scroll from jumping\n\n        setTimeout(() => {\n          const yPos = hashElement.offsetTop - this.offset;\n\n          this.scrollContainer.scrollTo(0, yPos);\n          // Sets the hash back with pushState so it won't jump to the element ignoring the offset\n          this.pushHashToUrl(hash);\n        }, 0);\n      },\n\n      /**\n       * Pushes the given hash to the URL using primarily pushState if available to prevent the\n       * scroll from jumping to the hash element. Uses window.location.hash as a fallback.\n       *\n       * @param {String} hash The hash value to be pushed\n       */\n      pushHashToUrl(hash) {\n        if (window.history.pushState) {\n          window.history.pushState(null, null, hash);\n\n          return;\n        }\n\n        window.location.hash = hash;\n      },\n    },\n  };\n</script>\n"]}]}