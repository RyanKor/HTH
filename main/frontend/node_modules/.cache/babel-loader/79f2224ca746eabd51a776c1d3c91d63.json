{"remainingRequest":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-scrollactive\\src\\scrollactive.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-scrollactive\\src\\scrollactive.vue","mtime":499162500000},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1563805362193},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":1563805359688},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1563805362193},{"path":"C:\\Users\\Administrator\\Desktop\\hth_dev\\HTH\\main\\frontend\\node_modules\\vue-loader\\lib\\index.js","mtime":1563805391247}],"contextDependencies":[],"result":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n//\n//\n//\n//\n//\n//\nimport bezierEasing from 'bezier-easing';\nexport default {\n  props: {\n    /**\n     * Class that will be applied in the menu item.\n     *\n     * @default 'is-active'\n     * @type {String}\n     */\n    activeClass: {\n      type: String,\n      default: 'is-active'\n    },\n\n    /**\n     * Amount of space between top of screen and the section to highlight. (Usually your fixed\n     * header's height)\n     *\n     * @default 20\n     * @type {Number}\n     */\n    offset: {\n      type: Number,\n      default: 20\n    },\n\n    /**\n     * Amount of space between the top of the screen and the section to highlight when clicking a\n     * scrollactive item to scroll. It will use the value of the `offset` prop if none is provided\n     * here. Usefull when you want to use the `offset` prop to make an item be active as soon as\n     * it shows on the screen but still scroll to the top of the section when clicking the item.\n     */\n    scrollOffset: {\n      type: Number,\n      default: null\n    },\n\n    /**\n     * The selector string of the scroll container element you'd like to use. It defaults to the\n     * window object (most common), but you might want to change in case you're using an element\n     * as the overflow container.\n     *\n     * @type {String}\n     */\n    scrollContainerSelector: {\n      type: String,\n      default: ''\n    },\n\n    /**\n     * Enables/disables the scrolling when clicking in a menu item.\n     * Disable if you'd like to handle the scrolling by your own.\n     *\n     * @default true\n     * @type {Boolean}\n     */\n    clickToScroll: {\n      type: Boolean,\n      default: true\n    },\n\n    /**\n     * The duration of the scroll animation when clicking to scroll is activated.\n     *\n     * @default 600\n     * @type {Number}\n     */\n    duration: {\n      type: Number,\n      default: 600\n    },\n\n    /**\n     * Defines if the plugin should track the section change when clicking an item to scroll to\n     * its section. If set to true, it will always keep track and change the active class to the\n     * current section while scrolling, if false, the active class will be immediately applied to\n     * the clicked menu item, ignoring the passed sections until the scrolling is over.\n     *\n     * @default false\n     * @type {Boolean}\n     */\n    alwaysTrack: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * Your custom easing value for the click to scroll functionality.\n     * It must be a string with 4 values separated by commas in a cubic bezier format.\n     *\n     * @default '.5,0,.35,1'\n     * @type {String}\n     */\n    bezierEasingValue: {\n      type: String,\n      default: '.5,0,.35,1'\n    },\n\n    /**\n     * Decides if the URL should be modified with the section id when clicking a scrollactive\n     * item.\n     *\n     * @default true\n     * @type {Boolean}\n     */\n    modifyUrl: {\n      type: Boolean,\n      default: true\n    },\n\n    /**\n     * If true the active class will only be applied when a section matches exactly one of the\n     * scrollactive items, meaning it will be highlighted when scrolling exactly inside the\n     * section. If false (default) it will always highlight the last item which was matched\n     * in a section, even if it is already outside that section (and not inside another that's\n     * being tracked).\n     *\n     * @default false\n     * @type {Boolean}\n     */\n    exact: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * If true the active class will be applied to the first scrollactive-item before you scroll\n     * past it (even if you didn't reach it yet).\n     */\n    highlightFirstItem: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * Change the scroll active component html tag.\n     *\n     * @default nav\n     * @type {String}\n     */\n    tag: {\n      type: String,\n      default: 'nav'\n    }\n  },\n  data: function data() {\n    return {\n      observer: null,\n      items: [],\n      currentItem: null,\n      lastActiveItem: null,\n      scrollAnimationFrame: null,\n      bezierEasing: bezierEasing\n    };\n  },\n  computed: {\n    /**\n     * Computes the bezier easing string value into an array.\n     *\n     * @return {Array.<string>}\n     */\n    cubicBezierArray: function cubicBezierArray() {\n      return this.bezierEasingValue.split(',');\n    },\n    scrollContainer: function scrollContainer() {\n      var container = window;\n\n      if (this.scrollContainerSelector) {\n        container = document.querySelector(this.scrollContainerSelector) || window;\n      }\n\n      return container;\n    }\n  },\n  mounted: function mounted() {\n    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n    if (!this.observer) {\n      // Watch for DOM changes in the scrollactive element wrapper\n      this.observer = new MutationObserver(this.initScrollactiveItems);\n      this.observer.observe(this.$refs['scrollactive-nav-wrapper'], {\n        childList: true,\n        subtree: true\n      });\n    }\n\n    this.initScrollactiveItems();\n    this.removeActiveClass();\n    this.currentItem = this.getItemInsideWindow();\n    if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n    this.scrollToHashElement();\n    this.scrollContainer.addEventListener('scroll', this.onScroll);\n  },\n  updated: function updated() {\n    this.initScrollactiveItems();\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.scrollContainer.removeEventListener('scroll', this.onScroll);\n    window.cancelAnimationFrame(this.scrollAnimationFrame);\n  },\n  methods: {\n    /**\n     * Will be called when scrolling event is triggered to handle the addition of the active class\n     * in the current section item and fire the change event.\n     *\n     * @param {Object} event Scroll event.\n     */\n    onScroll: function onScroll(event) {\n      this.currentItem = this.getItemInsideWindow();\n\n      if (this.currentItem !== this.lastActiveItem) {\n        this.removeActiveClass();\n        this.$emit('itemchanged', event, this.currentItem, this.lastActiveItem);\n        this.lastActiveItem = this.currentItem;\n      } // Current item might be null if not inside any section\n\n\n      if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n    },\n\n    /**\n     * Gets the scrollactive item that corresponds to the current section inside the window\n     *\n     * @return {Element} Scrollactive item element.\n     */\n    getItemInsideWindow: function getItemInsideWindow() {\n      var _this = this;\n\n      var currentItem; // Must be called with 'call' to prevent bugs on some devices\n\n      [].forEach.call(this.items, function (item) {\n        var isFirstItem = item === _this.items[0];\n        var target = document.getElementById(decodeURI(item.hash.substr(1)));\n        if (!target) return;\n        var distanceFromTop = _this.scrollContainer.scrollTop || window.pageYOffset;\n\n        var isScreenPastSection = distanceFromTop >= _this.getOffsetTop(target) - _this.offset;\n\n        var isScreenBeforeSectionEnd = distanceFromTop < _this.getOffsetTop(target) - _this.offset + target.offsetHeight;\n\n        if (isFirstItem && _this.highlightFirstItem) {\n          if (isScreenBeforeSectionEnd) currentItem = item;\n        }\n\n        if (_this.exact && isScreenPastSection && isScreenBeforeSectionEnd) currentItem = item;\n        if (!_this.exact && isScreenPastSection) currentItem = item;\n      });\n      return currentItem;\n    },\n\n    /**\n     * Sets the list of menu items, adding or removing the click listener depending on the\n     * clickToScroll prop.\n     */\n    initScrollactiveItems: function initScrollactiveItems() {\n      var _this2 = this;\n\n      this.items = this.$el.querySelectorAll('.scrollactive-item');\n\n      if (this.clickToScroll) {\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, function (item) {\n          item.addEventListener('click', _this2.handleClick);\n        });\n        return;\n      } // Must be called with 'call' to prevent bugs on some devices\n\n\n      [].forEach.call(this.items, function (item) {\n        item.removeEventListener('click', _this2.handleClick);\n      });\n    },\n\n    /**\n     * Keep the old setScrollactiveItems method in order to avoid breaking existing projects that\n     * used the previous version and upgraded to this one.\n     *\n     * @deprecated\n     */\n    setScrollactiveItems: function setScrollactiveItems() {\n      this.initScrollactiveItems();\n    },\n\n    /**\n     * Handles the scrolling when clicking a menu item.\n     *\n     * @param {Object} event The click event.\n     */\n    handleClick: function handleClick(event) {\n      var _this3 = this;\n\n      event.preventDefault();\n      var hash = event.currentTarget.hash;\n      var target = document.getElementById(decodeURI(hash.substr(1)));\n\n      if (!target) {\n        console.warn(\"[vue-scrollactive] Element '\".concat(hash, \"' was not found. Make sure it is set in the DOM.\"));\n        return;\n      }\n      /**\n       *  Temporarily removes the scroll listener and the request animation frame so the active\n       *  class will only be applied to the clicked element, and not all elements while the window\n       *  is scrolling.\n       */\n\n\n      if (!this.alwaysTrack) {\n        this.scrollContainer.removeEventListener('scroll', this.onScroll);\n        window.cancelAnimationFrame(this.scrollAnimationFrame);\n        this.removeActiveClass();\n        event.currentTarget.classList.add(this.activeClass);\n      }\n\n      this.scrollTo(target).then(function () {\n        if (!_this3.alwaysTrack) {\n          _this3.scrollContainer.addEventListener('scroll', _this3.onScroll);\n\n          var findClickedItem = function findClickedItem(item) {\n            return decodeURI(item.hash.substr(1)) === target.id;\n          };\n\n          _this3.currentItem = [].find.call(_this3.items, findClickedItem);\n\n          if (_this3.currentItem !== _this3.lastActiveItem) {\n            _this3.$emit('itemchanged', null, _this3.currentItem, _this3.lastActiveItem);\n\n            _this3.lastActiveItem = _this3.currentItem;\n          }\n        }\n\n        if (_this3.modifyUrl) {\n          _this3.pushHashToUrl(hash);\n        }\n      });\n    },\n\n    /**\n     * Scrolls the page to the given target element.\n     *\n     * @param {Element} target DOM Element to scroll to.\n     * @return {Promise} Returns a promise that will resolve when the animation is done.\n     */\n    scrollTo: function scrollTo(target) {\n      var _this4 = this;\n\n      return new Promise(function (resolve) {\n        var targetDistanceFromTop = _this4.getOffsetTop(target);\n\n        var startingY = _this4.scrollContainer.scrollTop || window.pageYOffset;\n        var difference = targetDistanceFromTop - startingY;\n\n        var easing = _this4.bezierEasing.apply(_this4, _toConsumableArray(_this4.cubicBezierArray));\n\n        var start = null;\n\n        var step = function step(timestamp) {\n          if (!start) start = timestamp;\n          var progress = timestamp - start;\n          var progressPercentage = progress / _this4.duration;\n          if (progress >= _this4.duration) progress = _this4.duration;\n          if (progressPercentage >= 1) progressPercentage = 1;\n          var offset = _this4.scrollOffset || _this4.offset;\n          var perTick = startingY + easing(progressPercentage) * (difference - offset);\n\n          _this4.scrollContainer.scrollTo(0, perTick);\n\n          if (progress < _this4.duration) {\n            _this4.scrollAnimationFrame = window.requestAnimationFrame(step);\n          } else {\n            resolve();\n          }\n        };\n\n        window.requestAnimationFrame(step);\n      });\n    },\n\n    /**\n     * Gets the top offset position of an element in the document.\n     *\n     * @param {Element} element\n     * @return {Number}\n     */\n    getOffsetTop: function getOffsetTop(element) {\n      var yPosition = 0;\n      var nextElement = element;\n\n      while (nextElement) {\n        yPosition += nextElement.offsetTop;\n        nextElement = nextElement.offsetParent;\n      }\n\n      if (this.scrollContainer.offsetTop) {\n        yPosition -= this.scrollContainer.offsetTop;\n      }\n\n      return yPosition;\n    },\n\n    /**\n     * Removes the active class from all scrollactive items.\n     */\n    removeActiveClass: function removeActiveClass() {\n      var _this5 = this;\n\n      // Must be called with 'call' to prevent bugs on some devices\n      [].forEach.call(this.items, function (item) {\n        item.classList.remove(_this5.activeClass);\n      });\n    },\n\n    /**\n     * Scrolls the page to the element passed as a hash in URL, preventing weird native scroll\n     * jumps while maintaining the hash in the URL.\n     */\n    scrollToHashElement: function scrollToHashElement() {\n      var _this6 = this;\n\n      var hash = window.location.hash;\n      if (!hash) return;\n      var hashElement = document.querySelector(decodeURI(hash));\n      if (!hashElement) return;\n      window.location.hash = ''; // Clears the hash to prevent scroll from jumping\n\n      setTimeout(function () {\n        var yPos = hashElement.offsetTop - _this6.offset;\n\n        _this6.scrollContainer.scrollTo(0, yPos); // Sets the hash back with pushState so it won't jump to the element ignoring the offset\n\n\n        _this6.pushHashToUrl(hash);\n      }, 0);\n    },\n\n    /**\n     * Pushes the given hash to the URL using primarily pushState if available to prevent the\n     * scroll from jumping to the hash element. Uses window.location.hash as a fallback.\n     *\n     * @param {String} hash The hash value to be pushed\n     */\n    pushHashToUrl: function pushHashToUrl(hash) {\n      if (window.history.pushState) {\n        window.history.pushState(null, null, hash);\n        return;\n      }\n\n      window.location.hash = hash;\n    }\n  }\n};",{"version":3,"sources":["scrollactive.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <component :is=\"tag\" class=\"scrollactive-nav\" ref=\"scrollactive-nav-wrapper\">\n    <slot></slot>\n  </component>\n</template>\n\n<script>\n  import bezierEasing from 'bezier-easing';\n\n  export default {\n    props: {\n      /**\n       * Class that will be applied in the menu item.\n       *\n       * @default 'is-active'\n       * @type {String}\n       */\n      activeClass: {\n        type: String,\n        default: 'is-active',\n      },\n\n      /**\n       * Amount of space between top of screen and the section to highlight. (Usually your fixed\n       * header's height)\n       *\n       * @default 20\n       * @type {Number}\n       */\n      offset: {\n        type: Number,\n        default: 20,\n      },\n\n      /**\n       * Amount of space between the top of the screen and the section to highlight when clicking a\n       * scrollactive item to scroll. It will use the value of the `offset` prop if none is provided\n       * here. Usefull when you want to use the `offset` prop to make an item be active as soon as\n       * it shows on the screen but still scroll to the top of the section when clicking the item.\n       */\n      scrollOffset: {\n        type: Number,\n        default: null,\n      },\n\n      /**\n       * The selector string of the scroll container element you'd like to use. It defaults to the\n       * window object (most common), but you might want to change in case you're using an element\n       * as the overflow container.\n       *\n       * @type {String}\n       */\n      scrollContainerSelector: {\n        type: String,\n        default: '',\n      },\n\n      /**\n       * Enables/disables the scrolling when clicking in a menu item.\n       * Disable if you'd like to handle the scrolling by your own.\n       *\n       * @default true\n       * @type {Boolean}\n       */\n      clickToScroll: {\n        type: Boolean,\n        default: true,\n      },\n\n      /**\n       * The duration of the scroll animation when clicking to scroll is activated.\n       *\n       * @default 600\n       * @type {Number}\n       */\n      duration: {\n        type: Number,\n        default: 600,\n      },\n\n      /**\n       * Defines if the plugin should track the section change when clicking an item to scroll to\n       * its section. If set to true, it will always keep track and change the active class to the\n       * current section while scrolling, if false, the active class will be immediately applied to\n       * the clicked menu item, ignoring the passed sections until the scrolling is over.\n       *\n       * @default false\n       * @type {Boolean}\n       */\n      alwaysTrack: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * Your custom easing value for the click to scroll functionality.\n       * It must be a string with 4 values separated by commas in a cubic bezier format.\n       *\n       * @default '.5,0,.35,1'\n       * @type {String}\n       */\n      bezierEasingValue: {\n        type: String,\n        default: '.5,0,.35,1',\n      },\n\n      /**\n       * Decides if the URL should be modified with the section id when clicking a scrollactive\n       * item.\n       *\n       * @default true\n       * @type {Boolean}\n       */\n      modifyUrl: {\n        type: Boolean,\n        default: true,\n      },\n\n      /**\n       * If true the active class will only be applied when a section matches exactly one of the\n       * scrollactive items, meaning it will be highlighted when scrolling exactly inside the\n       * section. If false (default) it will always highlight the last item which was matched\n       * in a section, even if it is already outside that section (and not inside another that's\n       * being tracked).\n       *\n       * @default false\n       * @type {Boolean}\n       */\n      exact: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * If true the active class will be applied to the first scrollactive-item before you scroll\n       * past it (even if you didn't reach it yet).\n       */\n      highlightFirstItem: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * Change the scroll active component html tag.\n       *\n       * @default nav\n       * @type {String}\n       */\n      tag: {\n        type: String,\n        default: 'nav',\n      },\n    },\n\n    data() {\n      return {\n        observer: null,\n        items: [],\n        currentItem: null,\n        lastActiveItem: null,\n        scrollAnimationFrame: null,\n        bezierEasing,\n      };\n    },\n\n    computed: {\n      /**\n       * Computes the bezier easing string value into an array.\n       *\n       * @return {Array.<string>}\n       */\n      cubicBezierArray() {\n        return this.bezierEasingValue.split(',');\n      },\n\n      scrollContainer() {\n        let container = window;\n\n        if (this.scrollContainerSelector) {\n          container = document.querySelector(this.scrollContainerSelector) || window;\n        }\n\n        return container;\n      },\n    },\n\n    mounted() {\n      const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n      if (!this.observer) {\n        // Watch for DOM changes in the scrollactive element wrapper\n        this.observer = new MutationObserver(this.initScrollactiveItems);\n        this.observer.observe(this.$refs['scrollactive-nav-wrapper'], {\n          childList: true,\n          subtree: true,\n        });\n      }\n\n      this.initScrollactiveItems();\n      this.removeActiveClass();\n      this.currentItem = this.getItemInsideWindow();\n\n      if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n\n      this.scrollToHashElement();\n      this.scrollContainer.addEventListener('scroll', this.onScroll);\n    },\n\n    updated() {\n      this.initScrollactiveItems();\n    },\n\n    beforeDestroy() {\n      this.scrollContainer.removeEventListener('scroll', this.onScroll);\n      window.cancelAnimationFrame(this.scrollAnimationFrame);\n    },\n\n    methods: {\n      /**\n       * Will be called when scrolling event is triggered to handle the addition of the active class\n       * in the current section item and fire the change event.\n       *\n       * @param {Object} event Scroll event.\n       */\n      onScroll(event) {\n        this.currentItem = this.getItemInsideWindow();\n\n        if (this.currentItem !== this.lastActiveItem) {\n          this.removeActiveClass();\n          this.$emit('itemchanged', event, this.currentItem, this.lastActiveItem);\n          this.lastActiveItem = this.currentItem;\n        }\n\n        // Current item might be null if not inside any section\n        if (this.currentItem) this.currentItem.classList.add(this.activeClass);\n      },\n\n      /**\n       * Gets the scrollactive item that corresponds to the current section inside the window\n       *\n       * @return {Element} Scrollactive item element.\n       */\n      getItemInsideWindow() {\n        let currentItem;\n\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          const isFirstItem = (item === this.items[0]);\n          const target = document.getElementById(decodeURI(item.hash.substr(1)));\n\n          if (!target) return;\n\n          const distanceFromTop = this.scrollContainer.scrollTop || window.pageYOffset;\n          const isScreenPastSection = distanceFromTop >= this.getOffsetTop(target) - this.offset;\n          const isScreenBeforeSectionEnd = distanceFromTop\n            < (this.getOffsetTop(target) - this.offset) + target.offsetHeight;\n\n          if (isFirstItem && this.highlightFirstItem) {\n            if (isScreenBeforeSectionEnd) currentItem = item;\n          }\n\n          if (this.exact && isScreenPastSection && isScreenBeforeSectionEnd) currentItem = item;\n          if (!this.exact && isScreenPastSection) currentItem = item;\n        });\n\n        return currentItem;\n      },\n\n\n      /**\n       * Sets the list of menu items, adding or removing the click listener depending on the\n       * clickToScroll prop.\n       */\n      initScrollactiveItems() {\n        this.items = this.$el.querySelectorAll('.scrollactive-item');\n\n        if (this.clickToScroll) {\n          // Must be called with 'call' to prevent bugs on some devices\n          [].forEach.call(this.items, (item) => {\n            item.addEventListener('click', this.handleClick);\n          });\n\n          return;\n        }\n\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          item.removeEventListener('click', this.handleClick);\n        });\n      },\n\n      /**\n       * Keep the old setScrollactiveItems method in order to avoid breaking existing projects that\n       * used the previous version and upgraded to this one.\n       *\n       * @deprecated\n       */\n      setScrollactiveItems() {\n        this.initScrollactiveItems();\n      },\n\n      /**\n       * Handles the scrolling when clicking a menu item.\n       *\n       * @param {Object} event The click event.\n       */\n      handleClick(event) {\n        event.preventDefault();\n\n        const { hash } = event.currentTarget;\n        const target = document.getElementById(decodeURI(hash.substr(1)));\n\n        if (!target) {\n          console.warn(`[vue-scrollactive] Element '${hash}' was not found. Make sure it is set in the DOM.`);\n\n          return;\n        }\n\n        /**\n         *  Temporarily removes the scroll listener and the request animation frame so the active\n         *  class will only be applied to the clicked element, and not all elements while the window\n         *  is scrolling.\n         */\n        if (!this.alwaysTrack) {\n          this.scrollContainer.removeEventListener('scroll', this.onScroll);\n          window.cancelAnimationFrame(this.scrollAnimationFrame);\n\n          this.removeActiveClass();\n          event.currentTarget.classList.add(this.activeClass);\n        }\n\n        this.scrollTo(target)\n          .then(() => {\n            if (!this.alwaysTrack) {\n              this.scrollContainer.addEventListener('scroll', this.onScroll);\n              const findClickedItem = item => decodeURI(item.hash.substr(1)) === target.id;\n              this.currentItem = [].find.call(this.items, findClickedItem);\n\n              if (this.currentItem !== this.lastActiveItem) {\n                this.$emit('itemchanged', null, this.currentItem, this.lastActiveItem);\n                this.lastActiveItem = this.currentItem;\n              }\n            }\n\n            if (this.modifyUrl) {\n              this.pushHashToUrl(hash);\n            }\n          });\n      },\n\n      /**\n       * Scrolls the page to the given target element.\n       *\n       * @param {Element} target DOM Element to scroll to.\n       * @return {Promise} Returns a promise that will resolve when the animation is done.\n       */\n      scrollTo(target) {\n        return new Promise((resolve) => {\n          const targetDistanceFromTop = this.getOffsetTop(target);\n          const startingY = this.scrollContainer.scrollTop || window.pageYOffset;\n          const difference = targetDistanceFromTop - startingY;\n          const easing = this.bezierEasing(...this.cubicBezierArray);\n          let start = null;\n\n          const step = (timestamp) => {\n            if (!start) start = timestamp;\n\n            let progress = timestamp - start;\n            let progressPercentage = progress / this.duration;\n\n            if (progress >= this.duration) progress = this.duration;\n            if (progressPercentage >= 1) progressPercentage = 1;\n\n            const offset = this.scrollOffset || this.offset;\n            const perTick = startingY + (easing(progressPercentage) * (difference - offset));\n\n            this.scrollContainer.scrollTo(0, perTick);\n\n            if (progress < this.duration) {\n              this.scrollAnimationFrame = window.requestAnimationFrame(step);\n            } else {\n              resolve();\n            }\n          };\n\n          window.requestAnimationFrame(step);\n        });\n      },\n\n      /**\n       * Gets the top offset position of an element in the document.\n       *\n       * @param {Element} element\n       * @return {Number}\n       */\n      getOffsetTop(element) {\n        let yPosition = 0;\n        let nextElement = element;\n\n        while (nextElement) {\n          yPosition += (nextElement.offsetTop);\n          nextElement = nextElement.offsetParent;\n        }\n\n        if (this.scrollContainer.offsetTop) {\n          yPosition -= this.scrollContainer.offsetTop;\n        }\n\n        return yPosition;\n      },\n\n      /**\n       * Removes the active class from all scrollactive items.\n       */\n      removeActiveClass() {\n        // Must be called with 'call' to prevent bugs on some devices\n        [].forEach.call(this.items, (item) => {\n          item.classList.remove(this.activeClass);\n        });\n      },\n\n      /**\n       * Scrolls the page to the element passed as a hash in URL, preventing weird native scroll\n       * jumps while maintaining the hash in the URL.\n       */\n      scrollToHashElement() {\n        const { hash } = window.location;\n        if (!hash) return;\n\n        const hashElement = document.querySelector(decodeURI(hash));\n        if (!hashElement) return;\n\n        window.location.hash = ''; // Clears the hash to prevent scroll from jumping\n\n        setTimeout(() => {\n          const yPos = hashElement.offsetTop - this.offset;\n\n          this.scrollContainer.scrollTo(0, yPos);\n          // Sets the hash back with pushState so it won't jump to the element ignoring the offset\n          this.pushHashToUrl(hash);\n        }, 0);\n      },\n\n      /**\n       * Pushes the given hash to the URL using primarily pushState if available to prevent the\n       * scroll from jumping to the hash element. Uses window.location.hash as a fallback.\n       *\n       * @param {String} hash The hash value to be pushed\n       */\n      pushHashToUrl(hash) {\n        if (window.history.pushState) {\n          window.history.pushState(null, null, hash);\n\n          return;\n        }\n\n        window.location.hash = hash;\n      },\n    },\n  };\n</script>\n"],"sourceRoot":"node_modules/vue-scrollactive/src"}]}